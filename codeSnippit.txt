
Notes:
The calibration data that needs to be saved and read back:

'''
struct bme69x_calib_data
{
    /*! Calibration coefficient for the humidity sensor */
    int16_t par_h1;

    /*! Calibration coefficient for the humidity sensor */
    int8_t par_h2;

    /*! Calibration coefficient for the humidity sensor */
    uint8_t par_h3;

    /*! Calibration coefficient for the humidity sensor */
    int8_t par_h4;

    /*! Calibration coefficient for the humidity sensor */
    int16_t par_h5;

    /*! Calibration coefficient for the humidity sensor */
    uint8_t par_h6;

    /*! Calibration coefficient for the gas sensor */
    int8_t par_g1;

    /*! Calibration coefficient for the gas sensor */
    int16_t par_g2;

    /*! Calibration coefficient for the gas sensor */
    int8_t par_g3;

    /*! Calibration coefficient for the temperature sensor */
    uint16_t par_t1;

    /*! Calibration coefficient for the temperature sensor */
    uint16_t par_t2;

    /*! Calibration coefficient for the temperature sensor */
    int8_t par_t3;

    /*! Calibration coefficient for the pressure sensor */
    int16_t par_p5;

    /*! Calibration coefficient for the pressure sensor */
    int16_t par_p6;

    /*! Calibration coefficient for the pressure sensor */
    int8_t par_p7;

    /*! Calibration coefficient for the pressure sensor */
    int8_t par_p8;

    /*! Calibration coefficient for the pressure sensor */
    uint16_t par_p1;

    /*! Calibration coefficient for the pressure sensor */
    uint16_t par_p2;

    /*! Calibration coefficient for the pressure sensor */
    int8_t par_p3;

    /*! Calibration coefficient for the pressure sensor */
    int8_t par_p4;

    /*! Calibration coefficient for the pressure sensor */
    int16_t par_p9;

    /*! Calibration coefficient for the pressure sensor */
    int8_t par_p10;

    int8_t par_p11;
#ifndef BME69X_USE_FPU

    /*! Variable to store the intermediate temperature coefficient */
    int32_t t_fine;
#else

    /*! Variable to store the intermediate temperature coefficient */
    float t_fine;
#endif

    /*! Heater resistance range coefficient */
    uint8_t res_heat_range;

    /*! Heater resistance value coefficient */
    int8_t res_heat_val;

    /*! Gas resistance range switching error coefficient */
    int8_t range_sw_err;
};
'''

Lorawan app key. Individual keys for devices and their sensors so that makes two unique app keys, per device. 

Encryption keys for secure OTA updates, if we have enough time for it. If OTA update failed, it needs to be reset locally. Saving offline data and error keys.


| Error Code                       | Meaning                | When It Happens |
| -------------------------------- | ---------------------- | --------------- |
| **ESP_OK**                       | Success                | â€”               |
| **ESP_ERR_NVS_NOT_FOUND**        | Key not present        | Reads           |
| **ESP_ERR_NVS_INVALID_LENGTH**   | Buffer too small       | Reads/writes    |
| **ESP_ERR_NVS_NOT_ENOUGH_SPACE** | Partition full         | Writes          |
| **ESP_ERR_NVS_TYPE_MISMATCH**    | Wrong data type        | Read or write   |
| **ESP_ERR_NVS_INVALID_NAME**     | Invalid key name       | Write           |
| **ESP_ERR_NVS_READ_ONLY**        | Partition cannot write | Write           |
| **ESP_ERR_NVS_NOT_INITIALIZED**  | Forgot init            | Read/write      |
| **ESP_ERR_NVS_PART_NOT_FOUND**   | No NVS partition       | init/open       |
| **ESP_ERR_FLASH_BASE**           | Flash malfunction      | Rare            |



When using these API calls remmer that the str variation includes the null terminator (\0).

esp_err_t nvs_get_blob(nvs_handle_t handle, const char *key, void *out_value, size_t *length)

and esp_err_t nvs_get_str(nvs_handle_t handle, const char *key, void *out_value, size_t *length)

Official docs:
It is suggested that nvs_get/set_str is used for zero-terminated C strings, and nvs_get/set_blob used for arbitrary data structures.

NVS requires you to know the type used when the data was written. There is no built-in API that tells you the type of a key, and NVS enforces type correctness:
if you read with the wrong getter, it returns ESP_ERR_NVS_TYPE_MISMATCH.

 esp_err_t nvs_get_stats(const char *part_name, nvs_stats_t *nvs_stats)


Return type meaning from the code.

Returns:

        ESP_OK if storage was successfully initialized.

        ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)

        ESP_ERR_NOT_FOUND if no partition with label "nvs" is found in the partition table

        ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures

        one of the error codes from the underlying flash storage driver

        error codes from nvs_flash_read_security_cfg API (when "NVS_ENCRYPTION" is enabled).

        error codes from nvs_flash_generate_keys API (when "NVS_ENCRYPTION" is enabled).

        error codes from nvs_flash_secure_init_partition API (when "NVS_ENCRYPTION" is enabled) .
